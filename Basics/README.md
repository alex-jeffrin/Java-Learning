# Java notes

**The following readme carries notes for the following chapters**
- [x] **CHAPTER 6 Introducing Classes**
- [x] **CHAPTER 7 A Closer Look at Methods and Classes**
- [x] **CHAPTER 8 Inheritance**
- [x] **CHAPTER 9 Packages and Interfaces**
- [ ] **CHAPTER 10 Exception Handling( Updating... )**

## Table of contents:
[1. classes](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#updating)

[2. General form of class](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#2-general-form-of-class-)

[3. Declaring objects](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#3-declaring-objects)

[4. Methods](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#4-methods)

[5. Method inside a class](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#5-methods-inside-a-class)

[6. returning value](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#6returning-value)

[7. Method with parameter](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#7-methods-with-parameter)

[8. Constructors](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#8-constructors)

[9. Parameterized constructors](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#9-parameterized-constructors)

[10. The this keyword](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#10-the-this-keyword)

[11. Overloading method](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#11-method-overloading)

[12. Overloading constructors](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#12-constructor-overloading)

[13. Objects as parameters](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#13-objects-as-parameters)

[14. Garbage collection](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#14-garbage-collection)

[15. Finalize method](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#15-finalize-method)

[16. Closer look at argument passing ](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#16-closer-look-at-argument-passing)

[17. Returning objects ](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#17-returning-objects)

[18. Recursion ](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#18-recursion)

[19. Access control](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#19-access-control)

[20. Static ](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#20-static)

[21. Final](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#21-final)

[22. Array length attribute](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#22-array-length-attribute)

[23. Nested and inner classes](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#23-nested-and-inner-classes)

[24. command line arguments](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#24-command-line-arguments)

[25. Varargs : Variable length arguments](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#25-variable-length-arguments)

[26. varargs overloading](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#26-varargs-overloading)

[27. varargs and  ambiguity](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#27-varargs-and-ambiguity)

[28. Inheritance](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#28-inheritance)

[29. Member access and inheritance ](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#member-access-and-inheritance)

[30. Using super first use and second use](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#30-using-super)

[31. Multilevel](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#31-multilevel)

[32. order or the constructors](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#32-order-of-the-constructor)

[33. method overriding](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#33-method-overriding)

[34. Dynamic method dispatch](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#34-dynamic-method-dispatch)

[35. Abstract classes](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#35-abstract-classes)

[36. using final to stop overriding](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#36-using-final-to-stop-overriding)

[37. Using final to prevent inheritance](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#37-using-final-to-prevent-inheritance)

[38. Object class](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#38-object-class)

[39. Packages](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#39-packages)

[40. Access protection](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#40-access-protection)

[41. Importing packages](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#41-importing-packages)

[42. Interfaces](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#42-interfaces)

[43. Implementing interfaces](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#43-implementing-interfaces)

[44. Partial implementation](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#44-partial-implementation)

[45. Nested interfaces](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#45-nested-interfaces)

[46. Applying interfaces](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#46-applying-interfaces)

[47. interfaces can be extended](https://github.com/alex-jeffrin/INCUBATION_PROCESS/tree/master/Basics#47-interfaces-can-be-extended)



## 1. classes 
  classes in other words are used defined data types. it also has its own default constructor.those constructors can also me overriden. class has varible declared it will be called as instance varable when an object is created.

## 2. General form of class :
 classes have the following syntax to declare 

 ```java 
 Classname objectname = new classname();
 ```
 it can also be written as 

```java 
 Classname objectname ;
 objectname = new Classname();
```
first it create a reference of class as a type and initially it will be null. and while executing the second statement it creates a dynamic memory in heap memory and the address of the memory is stored in that variable.


The structure of the class will be as follow 

```java
class classname {
  datatype instance-variable1 ;
  datatype instance-variable2 ;

  type method(){
    //Statement to execute
  }

  access_specifier type method(parameter){
    //Statement to execute
  }
}
```

## 3. Declaring objects 


Declaring of objects are as follow

 ```java 
 Classname objectname = new classname();
 ```

 we can also reference an object to a new variable as like below

 
 ```java 
 Classname objectname1 = new classname();

 Classname objectname2 = objectname1;


 ```

 ## 4. Methods

 the methods are functions that are declared inside the class. the methods inside the class can be used after creating an object for the class. The general form of a method is as show below 

 ```java 
 access_modifier return_type method_name(type parameters){

  //statements to be executed
  //body of method
  return value;
 }
```


## 5. Methods inside a class 
a method inside a class can be accesed after the object is created for the class. after creation of the object those methods can be accessed using the dot (.) Operator as shown below.

```java
class classname {
  access_modifier return_type method_name(type parameters){

  //statements to be executed
  //body of method
  return value;
 }
}

class MethodExample{
  public static void main (String args[]){
    classname obj1 = new classname();   //creating an object for the class

    type variable = obj1.methodname();  //now this line calls the method and assign the returned value to the variable 

  }
}

```

## 6.Returning value
In the ablove topic in the methodswe would have used a word called return value. the return value is a value that is reurned at the end of executing a statement from a metdhod to assign to other. so in the same example given above


```java
class classname {
  access_modifier return_type method_name(type parameters){

  //statements to be executed
  //body of method
  return value;
 }
}

class MethodExample{
  public static void main (String args[]){
    classname obj1 = new classname();   //creating an object for the class

    type variable = obj1.methodname();  //now this line calls the method and assign the returned value to the variable 

  }
}

```

we are able to see that we create an object and we assign the return value from the method to a new variable. which actually brings a returned value from the method that has been called.

## 7. Methods with parameter
The methods may have parameter, which are like boundries we need to give values without exceeding the boundries. for example if we declare a method that does addition of two values. we need to give a parameter with two variables. those 2 variables that are passed are called arguments.

we need to declare the type we are going to pass as argument. The argument passed must match the datatype that has been defined in the parameter. lets se a sumple addition of two numbers program

```java
class AddTwo{

    public int additionMethod(int m,int n){ //parameter with two variables of int datatype...

        return m+ n;
        
    }
}

class AdditionOfTwo{
    
    public static void main (String args[]){
        
        int a = 6;
        int b = 4;
        AddTwo obj1 = new AddTwo();

        int c= obj1.additionMethod(a,b);
        System.out.println(c);
        
    }
}
```

In the above program a varable c assigned to the methods return value. Initially it looks throught the method that has been called inside the object. Two values have been passed as argument which will enter the method and after entering, The method return the summation of two numbers as return value. the value returned will be assigned to the variable c. the output will be as below 

### Output :

```bash 
c:\Users\ExampleProgram> javac AdditionOfTwo.java
c:\Users\ExampleProgram> java AdditionOfTwo

10

Process finished with exit code 0
```
## 8. Constructors
Constuctors are like default methods that will be called whenevere an object is created. those constructors can also be overridden by the user to ask for the variables while creating an object, We can create a class with default values or properties with the constructor. Constructor method will have the same name as the class name. It may have parameters that user need to give when the creation of object, or the default constructor may have some other value to be initialized during the creation of the object. below is the example code for constructor.

```java 
class AddTwo{

    int m ;
    int n;

    AddTwo(){
        int m = 2;
        int n = 3;
    }

    AddTwo(int i, int j){

        int m = i;
        int n = j;

    }

    public int additionMethod(){ //parameter with two variables of int datatype...

        return m+ n;

    }
}

class AdditionOfTwo{

    public static void main (String args[]){

        int a = 6;
        int b = 4;
        AddTwo obj1 = new AddTwo();
        AddTwo obj2 = new AddTwo(a,b);


        int c = obj1.additionMethod();
        int d = obj2.additionMethod();
        
        System.out.println("Object with no parameters : "+ c);
        System.out.println("Object with 2 parameters : "+d);

    }
}
```

In the above example we have created two constructors one with the default values and another one with a parameter which expects two arguments from the user to give. Now there is option either user can give parameter during initialization of object or it can be emplty so that the constructor by default it will  assign the value as m = 1 and n = 6. the output will be as follow 

### Output :
```bash 
c:\Users\ExampleProgram> javac AdditionOfTwo.java
c:\Users\ExampleProgram> java AdditionOfTwo

Object with no parameters : 5
Object with 2 parameters : 10

Process finished with exit code 0
```

## 9. Parameterized constructors
Parameterized constructor example is given above. the constructor ecpects parameters to be passed during the creation of objects
```java
class AddTwo{

    int m ;
    int n;

    AddTwo(int i, int j){

        int m = i;
        int n = j;

    }

    public int additionMethod(){ 

        return m+ n;

    }
}

class AdditionOfTwo{

    public static void main (String args[]){

        int a = 6;
        int b = 4;
        AddTwo obj1 = new AddTwo(a,b);  //parameters passed during creation of objects.


        int c = obj1.additionMethod();
        
        System.out.println("Object with parameters : "+ c);

    }
}
```
The above program expects the user to give two values when the objects are created for the classes as there is no default value constructor it will shows error during the compile time if the user forgets to give the parameter for the objects during the initialization.

## 10. The this keyword
The **this** keyword is  used to refer the current object that has been called. it is majorly used to prevent naming classhed during assigning the local varibale to the instance variable through parameters.
for example take the below program.
```java
class AddTwo{

    int m ;
    int n;

    AddTwo(int i, int j){

        i = i;
        j = j;

    }
}
```
In the above class the class the instance variable is named same as the local variable which is enterd as a parameter now there will be a class for assigning a variable it will be like i = i for the paramter value is assigned to itself instead of assigning to the instance variables. to prevent this we need to use the **this** keyword which will refer the current object. While using the this keyword with a variable it refers the variable of the specific instance sot the above program can be written as below

```java
class AddTwo{

    int m ;
    int n;

    AddTwo(int i, int j){

        this.i = i;
        this.j = j;

    }
}
```
now it takes the value from the parameter and assign the values to the curren objects variable without any clash.

## 11. Method overloading

Method overloading refers to defining methods with the same name multiple times.  to handle differnt scenarios of caliing the methods

A best example is that if we are having a function to add two numbers that takes two arguments as parameter. if the input is of int type there will be a seperate method to handle the int type method, another method will be there for handling the floating type. another type


```java
class AddTwo{

    int m ;
    int n;

    public int additionTwo (int i, int j){
      m = i;
      n = j;
      return m+n;
    
    }

    public int additionTwo (float i, float j){
      m = i;
      n = j;
      return m+n;
    
    }

    public int additionTwo (double i, double j){
      m = i;
      n = j;
      return m+n;
    
    }
    
}
```

This example relates with constructor overloading also, cause the constructor is also a method that is called at the initial stage of creating a object instance for a class.


## 12. Constructor overloading 

Conside the scenario. If an user is trying to create a constructor to initialize the value of instance varibles during the creation of the class objects.

For example if user enters arguments with different data type then these constructor overloading can be used by creating method with the same name but it asks for differnet datatype of parameter for better understanding lets take the below example.

```java
class AddTwo{

    int m ;
    int n;

    AddTwo(int i, int j){

        this.i = i;
        this.j = j;

    }
    AddTwo(float  i, float j){

        this.i = i;
        this.j = j;

    }
    AddTwo(double i, double j){

        this.i = i;
        this.j = j;

    }
    
}
```

So, in the above example the object needs two values as an arguments but event it is os int type or float or double based on the user input it will just select the method that suits the constructor that has been overloaded.


We have created three constructors that overloads the constructor methods. 
this concept of creating constructors with the same name for handling different datatype input from the user also comes under constructor overloading.

## 13. Objects as parameters
We can even pass objects as parameters for the methods that we use inside the classes. for example if we are having an object like box which is having its own dimension as height. width and breadth. we can use that object to assign those values to create a new object of the same class by passing this object as parameter and assigning by accessing the instance variable using the dot operator ( . ). Lets conside the example given below.

```java

class Box {
  int height;
  int width ;
  int breadth;

  Box(int i, int j, int  k) {
    height = i;
    width = j;
    breadth = k;
  }

  Box(Box obj){
    height = obj.height
    width = obj.width
    breadth = obj.breadth
  }

}

```
In the above example we can see that the object is passed as parameter and the instance variables of that object is referenced to the newly instanced object to be instanciated. this is method of passing object as a parameter.


## 14. Garbage collection

In our program we dynamically assign memory for the variables. so in oreder to save memory the garbage collector looks for the unused objects or the objects that are reference to null. It looks for the scope of the variable whether it is going to be used in later scenario else the garbage collector clears that memory.

The garbage collector runs priodically at a inknown point of time. We need not want to worry about that. 

but we can forcefully run the garbage collector by calling the static gc() method within the System class as metioned below.

```java
System.gc();
```
or 
```java
Runtime.getRuntime().gc();
```

There is no gurantee that the garbage collector runs at the specific time. By using the above two methods we request for the garbage collector from the JVM on which the application will be running.


## 15. Finalize method


Finalize is a method in java that is used to perfrom clean-up pocess when the garbage collector is called by the JVM. It is used with the objects while garbage collection. this process takes place before the destruction of an object. and it is invoke just befor the object is destroyed.

this is a default method that has the super class Object class. we need to override this method incase if we want to do any actions that is prior to the garbage collection of that object. the finalize method by default looks like below.

```java
protected void finalize() throws Throwable{

}
```
## 16. Closer look at argument passing

There are two types while passing the arguments to the parameters one is by value and one is by reference.

while we use the call by value then the value that has be used for the argument doesnt changes its original value outside the method from where it has been called. for example take the below code.

```java 
class CallClass {

  public void callTest (int i , int  j){
    i *= i;
    j *= j;
  }
}
class CallExample {
  public static void main (String args[]){
    int a = 5;
    int b = 6
    CallClass call = new CallClass();

    System.out.println("values of a and b before call : "+a+" "+b);
    call.callTest(a,b);
    System.out.println("values of a and b after call : "+a+" "+b);
  }
}
```

### Output :
```bash 
c:\Users\ExampleProgram> javac CallExample.java
c:\Users\ExampleProgram> java CallExample

values of a and b before call : 5 6
values of a and b after call : 5 6

Process finished with exit code 0
```

There is no change in the value outside the method or the variable that is  passed as an argument for that method.

In the other case we use the refernce of an object to call the value. In such cases the values called by the reference actually changes the original value that is used in the reference variable. A goof example of this is passing an object type as argument hold the reference of the object which could change the value outside the method also .

Consider the program given below.

```java
class CallClass {
  int i;
  int j;

  CallClass(int i, int j){
    this.i = i;
    this.j = j;
  }

  public void callTest (CallClass obj){
    obj.i += 5;
    obj.j += 5; 
  }
}
class CallExample {
  public static void main (String args[]){
    
    CallClass call = new CallClass(10,15);

    System.out.println("values of a and b before call : "+obj.i+" "+obj.j);
    call.callTest(a,b);
    System.out.println("values of a and b after call : "+obj.i+" "+obj.j);
  }
}
```
### Output :

```bash 
c:\Users\ExampleProgram> javac CallExample.java
c:\Users\ExampleProgram> java CallExample

values of a and b before call : 10 15
values of a and b after call : 15 20

Process finished with exit code 0
```

In the above program we are able to see that passing the object as a parameter changed the value inside the object reference so this is how the call by reference works.

## 17. Returning objects 
A method can also return an onject during the function call for example take the below code as an example

```java
class TestClass{
  
  int i;

  TestClass(int i){
    this.i = i;
  }

  public Testclass increaseByTen(){
    TestClass temp = temp TestClass(i+10);
    return temp;
  }
}
class ReturnObj{
  public static void main (String args[]){
    TestClass obj = new TestClass(10);
    obj2 = obj.increaseByTen();
    obj3 = obj2.increaseByTen();

    System.out.println("The value of obj : "+ obj.i)
    System.out.println("The value of obj2 : "+ obj2.i)
    System.out.println("The value of obj3 : "+ obj3.i)
    
  }
}
```

### Output : 
```bash
c:\Users\ExampleProgram> javac ReturnObj.java
c:\Users\ExampleProgram> java ReturnObj

The value of obj : 10 
The value of obj2 : 20
The value of obj3 : 30

Process finished with exit code 0
```


In the above code we create an object for the class with a default value of 10 using the constructor. after creating an object we are calling the increaseByTen method inside the object which returns an object by increasing the alue of the instance variable by 10. and then the object is then assigned to the new object variable. 

This is how methods inside the objects returns the objects as return values.

## 18. Recursion 
 
 Recusrsion is supported in java. It is a method of calling itself. A method is called by itself to make the complexity of the program simple.

 Lets take the following example of finding the factorial of number.

```java
class Factorial {
  int fact(int n){

    int result;

    if (n==1){
      return 1;
    }

    result = fact((n-1)*n);

  }
}

class RecursionExample{
  public static void main (String args[]){

    Factorial fc = new Factorial();

    System.out.println("The factorial of 3 is : "+fc.fact(3));
    System.out.println("The factorial of 4 is : "+fc.fact(4));
    System.out.println("The factorial of 5 is : "+fc.fact(5));

  }
}
```
In the above program we are able to see that we have called a method that result which recursively calls it till n-1 when the limit reaches 1 it will be returned and miltiplied with the previous number and so on it gets repeated. and below is the output.

### Output : 
```bash
c:\Users\ExampleProgram> javac RecursionExample.java
c:\Users\ExampleProgram> java RecursionExample

The factorial of 3 is : 6
The factorial of 4 is : 24
The factorial of 5 is : 120

Process finished with exit code 0
```

Here is another example for the usage of recursive function.
 
```java
import java.util.Scanner;

class RecursiveClass{
	
	int values[];
	
	RecursiveClass(int i ){
		values = new int[i];
	}
	
	void recursivePrint(int i){
		if (i==0)return ;
		else recursivePrint(i-1);
		System.out.println(values[i-1]);
	}
	
	
}

class Recursive{
	public static void main (String args[])
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Please enter the size of the array : ");
		int size = sc.nextInt();		
		RecursiveClass rc = new RecursiveClass(size);
		int i;
		for ( i = 0;i<size;i++){
			rc.values[i]=i;
		}
		
		rc.recursivePrint(size);
		
	}
}
```
 In the above code the user is asked for the input size of the array and the array size is initilized using the constructor of the class. after that the values at each positions are assigned using an iterator. after assigning the values using the recursive method the valyyes inside the array is displayed

## 19. Access control
java prived four access modifiers as given below.
  - Pulic 
  - Private 
  - Protected
  - Default (Provided by default when no access specifier is mentioned.) 

### Public :
&emsp; the classes, methods, instance variales and static variables are accessible any where from the code, even from out the package.

### Private :
&emsp; The methods and variables that are declared as private has the scope within the class it has been declared. even inner classes cannot access the variable directly which are declared as private.

### Protected: 
&emsp; The methods and variables that are declared as protected can be accessed only if the class is a inherited or by using the package.

### Default :
&emsp; The default is applied when no access modifier is specified. when we dont declare any access specifier the class, methods or variables are accessible only within the package

The table below shows the access levels of each modifiers.

Access levels | Private | Default | Protected | Public
---| ---| ---| ---| ---| 
**within class** | Yes |Yes | Yes |Yes
**within package** | No |Yes | Yes | Yes
**outside package but subclass** | No | No | Yes | Yes
**outside package** | No | No | No | Yes



## 20. Static 
Static keyword is used to methion the static variables and methods inside the java coe. every method and varaibles initialized as static are called first when the program is set to run. For example you would have seen a static block inside the main class. Yes exactly the static block befor the main class will execute first

```java 
class MainClass{
  static {
    System.out.println("Hi, this static block runs before the main method.");
  }

  public static void main (String args[]){
    System.out.println("This runs after the static block is executed.")
  }
}
```
### Output : 
```bash
c:\Users\ExampleProgram> javac MainClass.java
c:\Users\ExampleProgram> java MainClass

Hi, this static block runs before the main method.
This runs after the static block is executed.

Process finished with exit code 0
```
In the above example we are able to see that the static block defined before the main method is called before the main method is executed.

All the methods that are declared as a static can be accessed withot creating objects for that specific class. we can directly access the static methods using the dot operator as shown below.
 ```java 
 Classname.staicMethodname();
 ```
 We can event create objects for the static methods to be called but it is of no needed for static methods

 All the variables that are declared as static remains the same for all the objects of that particular class.
 Whenever an object is created for a class the instance variables that are declared as static will be the same and the variable declared as static will be shared between them and remains the same for all.
## 21. Final
When a varible is declared as final its values cannot be changed after initializing the value for the final variable

For example,

```java
final int i;
```
this declares a final variable named i of type int.

```java
i = 10;   //Accepted.

i = 16;   //Not Accepted.
```
After declaring a variable as a final variable once the value is assigned it cannot be modified. sam in the above code once the final variable i assigned to a valu 10 its not able to change the value of i. An attempt to change the value of i causes an error.

It is mostly used in the case of declaring constatnt variable so that the value cannot be changed inevitably.

## 22. Array length attribute
There is a length attibute in array, which is very useful in knowing the size of an array that has been declared. and also a main thing to notice is that the length of the array attribute has nothing to do with the number of elements that are present in the array. 

It just shows the size of an array.
```java

int arr[] = new int[10];
arr = {1,2,3,4,5};

System.out.println(arr.length);

```
We can see that there are only 5 values in that array but the actual size of the array is 10 and the length attribute of the array returns only the size of the array.
## 23. Nested and inner classes
As like methioned all the classes can have its own nested classes in java
those nested classes have all the properties of the super classes. it have access to all the members of the super class.
## 23. String class
The String is by default it is a class, whenever we try to create a string using the type String whe String implictity refers to a object type in java

```java
String newString = "This is a new string";
```
is same as,

```java
String newString = new String("This is a new string");
```
event though we didnt mention the new keyword in fir method it implicitly creates as an object.
## 24. command line arguments
The command line arguments are arguments that are passed along with the compiling of the main program in the command line for example,

``` bash 
c:\Users\ExampleProgram> javac MainClass.java
c:\Users\ExampleProgram> java MainClass This is a commandline argument
```

the sentence that is followed by the command is metioned as arguments that are passed through command line that are called as command line arguments.

these arguments are stored in the args[] array which is a parameter passed thoright the main method.
```java
public static void main (String args[]){
  ........
}
```
## 25. Varargs : Variable length arguments
varargs represents variable length arguments. this var args is used to define a method with variable length of arguments. For example, if there is a method with two arguments then the method must receive only two arguments. and it should not be above or below two arguments in this case if the user enter more arguments it shows an error. what if there is a method which may need more than 2 somethime and sometimes it needs less arguments. it can be achieved using the varargs(Variable length argument.)

the varargs is mentioned using dataype ... (Thriple dots). datatype followed by thriple dots followed by variable name Which stores the values as arrays.
```java
public int exampleMethod (int...n){

  // Statements to be executed

}
```
lets consider the example program given below.

```java
class VarargsClass{

    int values[];

    RecursiveClass(int ... i ){
        values = i;
        for (int x: values) {
            System.out.print(x +" ");
        }
        System.out.println();
    }

}

class VarargsExample{
    public static void main (String args[])
    {

        System.out.print("Parameters of 1st object :");
        VarargsClass obj1 = new VarargsClass(1,23,56,7,8,9,7);
        System.out.print("Parameters of 2nd object :");
        VarargsClass obj2 = new VarargsClass();
        System.out.print("Parameters of 3rd object :");
        VarargsClass obj3 = new VarargsClass(1,2,3);

    }
}
```
### Output:
``` bash 
c:\Users\ExampleProgram> javac VarargsClass.java
c:\Users\ExampleProgram> java VarargsClass 

Parameters of 1st object :1 23 56 7 8 9 7 
Parameters of 2nd object :
Parameters of 3rd object :1 2 3 

Process finished with exit code 0

```
in he above programwe have a constructor that can hava one or more arguments even zero arguments. this is refered as the variable length arguments.

## 25. varargs overloading
varargs overloading is similar to constructor overloading based on the variable length arguments the methods will be overloaded. for the varargs overloading example lets take the same constructor with var args but this time its overloaded

```java
class VarargsClass{

    VarargsClass(int ... i ){

        for (int x: i) {
            System.out.print(x +" ");
        }
        System.out.println();
    }
    VarargsClass(boolean ... i ){
        for (boolean x: i) {
            System.out.print(x +" ");
        }
        System.out.println();
    }

}

class Recursive{
    public static void main (String args[])
    {

        System.out.print("Parameters of 1st object :");
        VarargsClass obj1 = new VarargsClass(1,23,56,7,8,9,7);
        System.out.print("Parameters of 2nd object :");
        VarargsClass obj2 = new VarargsClass(true,true,false,true,false);
        System.out.print("Parameters of 3rd object :");
        VarargsClass obj3 = new VarargsClass(1,2,3);
        System.out.print("Parameters of 4th object :");
        VarargsClass obj4 = new VarargsClass(true,true);

    }
}
```
### Output:
``` bash 
c:\Users\ExampleProgram> javac VarargsClass.java
c:\Users\ExampleProgram> java VarargsClass 

Parameters of 1st object :1 23 56 7 8 9 7 
Parameters of 2nd object :true true false true false 
Parameters of 3rd object :1 2 3 
Parameters of 4th object :true true 

Process finished with exit code 0

```
So in the above class we have overloaded the constructor for accepting varargs but bassed on different datatype.
## 26. varargs and  ambiguity
varargs ambiguity is like when we are declaring variable length argument. in the case if we overload the constructor for different types and thos metho only varargs it'll get confused for example take the below code. 

```java
class RecursiveClass{

    RecursiveClass(int ... i ){

        for (int x: i) {
            System.out.print(x +" ");
        }
        System.out.println();
    }
    RecursiveClass(boolean ... i ){
        for (boolean x: i) {
            System.out.print(x +" ");
        }
        System.out.println();
    }

}

class Recursive{
    public static void main (String args[])
    {

        System.out.print("Parameters of 1st object :");
        RecursiveClass obj1 = new RecursiveClass(1,23,56,7,8,9,7);
        System.out.print("Parameters of 2nd object :");
        RecursiveClass obj2 = new RecursiveClass(true,true,false,true,false);
        System.out.print("Parameters of 3rd object :");
        RecursiveClass obj3 = new RecursiveClass(1,2,3);
        System.out.print("Parameters of 4th object :");
        RecursiveClass obj4 = new RecursiveClass(true,true);

        System.out.print("Parameters of 5th object :");
        //RecursiveClass obj5 = new RecursiveClass();

    }
}
```
In this java program we have overloaded the constructor with varargs parameter.if we are giving no arguments during the creation of objects then it will be confused where to go. either for boolean or int. in this care we need to have another method or constructor for this case. this is called as varargs and ambiguity. 
## 27. Inheritance
Inheritance is the cornerstone in OOP's concept in java. java support 3 types of inheritance namely
- Single inheritance

&emsp;&emsp;&emsp;&emsp; A class that can have one child or one subclass is called single inheritance 

- Multilevel inheritance

&emsp;&emsp;&emsp;&emsp; A class which is a subclass of another class acting as a parent of another class which also subclass and parent class for the below class and goes on 

- Hierarchial inheritance

&emsp;&emsp;&emsp;&emsp; A class that will be having two or more sublasses is called Hierarchial inheritance.

> **Note:** Multiple inheritance is not supported in java cause there migth be conflict when deriving two classes having method overridden but the method definition changes.

To derive a class we can user the keyword extend. For example, look at the program below 

```java
class A {
  int i;
}

class B extends A{
  int j;
}

class C extends B{
  int k
}

```
In this program we have used multilevel inheritance. B derives A and B has access to all the members of A class, and C derives B class which has all access of A class, Now C has access of both A and B class as well. For restricting access lets look at next topic

## 28. Member access and inheritance 
We can restric the access during inheritance by using access specifiers.
for example conside the follwoing code.

```java
class A {
  private int i;
}

class B extends A{
  protected int j;
}

class C extends B{
  public int k
}

class C extends B{
  
  C(){
  System.out.println(i);    //This variable is not accessible here and, shows error
  System.out.println(j);
  System.out.println(k);
  }
  
}

class InheritanceExample{
  public static void main (String args[]){
    C obj = new C();
  }
}

```
in the above program we have declare i as private in the top most super class which is not even accessible by the immediate subclass. so it cannot be acces outside to the class which it has been declared.

And in the class B we have declared j as a protected variable which will be accessed by the subclass. and ni the class C we have mad the k as public, It is also accessible by the following sub-classes. 

>**Notes :** Remember that all the subclasses can access the member of super classes bu the super classes will not be aware of the members of subclasses.
## 29. Using super
**First use :**

There is two ways in using the super keyword. first is used to call the conctructor of the parent class. it can be applicable in calling the methods also to call the methods of the parent classes we can user ther keyword super followed by dot operator (.) followed by the method name. incase if we  have to call the parent class's constructor we just need to use the super(). which must be the first statement inside a method.

**Second use :**

The second use of the super keyword is like this keyword if we are having sonstrictors that has the member variables in the same name. take the following example program
```java
class A{
  int i;
}
class B extends A{
  int i;
  B(int n){
    i = n;
  }
}
```
int the above piece of code we can see that there are two variables with the same name i and same type while initializing the value the instance variable of B hides the instance variable of A. In order to stop this and assign the new variable to the parent class we can use super to make this conflict clear. for example
```java
class A{
  int i;
}
class B extends A{
  int i;
  B(int n){
    super.i = n;
  }
}
```
this would solve the problem.
## 31. Multilevel
We have seen a program that implements the multilevel hierarchy in inheritance and the below program implements the multilevel hierarchy of inheritance.

```java
class A {
    private int i;
}

class B extends A{
    protected int j = 10;
}

class C extends B{
    public int k = 20;
}

class D extends C{

    D(){
        //System.out.println(i);    //This variable is not accessible here and, shows error
        System.out.println(j);
        System.out.println(k);
    }

}

class Recursive{
    public static void main (String args[]){
        D obj = new D();
    }
}
```
The above program will give the following output.

## Output:
```
c:\Users\ExampleProgram> javac VarargsClass.java
c:\Users\ExampleProgram> java VarargsClass 

10
20

Process finished with exit code 0
```
## 32. order or the constructors
The constructor of the classes executes in the order  of derivation. for example if we have a class A which has a subclass B and B also has its own subclass which is in multilevel inheritance. the constructors of each classes executes in the order of derivation of the classes. for example lets consider the below program 
```java
class A {
    A(){
        System.out.println("A\'s constructor ");
    }
}

class B extends A{
    B(){
        System.out.println("B\'s constructor.");
    }
}

class C extends B{
    C (){
        System.out.println("C\'s constructor.");
    }
}

class D extends C{

    D(){
        System.out.println("D\'s constructor.");
    }

}

class ConstructorOrder{
    public static void main (String args[]){
        D obj = new D();
    }
}
```
## Output:
```bash 
c:\Users\ExampleProgram> javac VarargsClass.java
c:\Users\ExampleProgram> java VarargsClass  

A's constructor 
B's constructor.
C's constructor.
D's constructor.

Process finished with exit code 0
```
In the above example we are able to see that the constructors are getting executed on the order of derivation of the classes in the order which the classes have derivated from the parent class.
## 33. method overriding
Method overriding refers to recreating the methods with the same name that exists in another class.
For example.
```java 
class A {
    private int i = 10;
    int show(){
        return i;
    }
}

class B extends A{
    int i = 29;
    B(){
        System.out.println("show method return the value of i from class B :"+show());
        System.out.println("super.show() method return the value of i from class A :"+super.show());
    }

    int show() {

        return i;
    }

}

class constructorOverriding{
    public static void main (String args[]){
        B obj = new B();

    }
}
```
## Output:
```bash
c:\Users\ExampleProgram> javac constructorOverriding.java
c:\Users\ExampleProgram> java constructorOverriding 

show method return the value of i from class B :29
super.show() method return the value of i from class A :10

Process finished with exit code 0
```
In the above program we have overriden the show method in A by creating a medhod with same name in the class B which derives A as it's parent class.


## 34. Dynamic method dispatch
Dynamic dispatch is also called as runtime polymorphism. Lets take the following program.
```java
class A {
    void show() {
        System.out.println("The method inside A is called.");
    }
}

class B extends A{

    void show() {
        System.out.println("The method inside B is called.");
    }

}

class C extends B{
    void show() {
        System.out.println("The method inside C is called.");
    }
}

class DynamicDispatch{
    public static void main (String args[]){
        A obj = new A();
        B obj2 = new B();
        C obj3 = new C();

        obj.show();
        obj2.show();
        obj3.show();

        A obj4 ;
        obj4 = new B();
        obj4.show();

        obj4 = new C();
        obj4.show();
    }
}
```

## Output :
```bash 
c:\Users\ExampleProgram> javac DynamicDispatch.java
c:\Users\ExampleProgram> java DynamicDispatch 

The method inside A is called.
The method inside B is called.
The method inside C is called.
The method inside B is called.
The method inside C is called.

Process finished with exit code 0
```
In the above program we can see that the show method in the class A is overriden by the two subclasses. so inthis case the respective objects for the class may call the methohds. but we can call the methods of other classes by declaring a refernce type of parent class and assigning the object of a subclass. this is called as dynamic method dispatch. the program implements the same an reference of type A is declared and then the objects of the differenct classes that has the overriden methods are assigned to the referenced type. so that the method will be called based on the assigned object
## 35. Abstract classes
In some situations we might want a super class that declares a method that must be overriden by the classes that derives this class in that case we can use abstract classes. Inside the abstract classes we declare methods instead of defining the methods. after declaring methods the classes that extends the abstract class must override the methods that are declared in the abstract class.  We cannot create objects for the abstract classes instead we can extend this class by deriving and we can create obejects for the classes. look at the program below
```java

Abstract class A{
  void display();
}

class B extends A{
  void display(){
    System.out.println("The class B has overriden the method display form the Abstract class.");
  }
}

```
In the above code we have the class A as a abstract class that has defined a method called display which must be overriden by the classes that inherits the abstract class. here the class B which extends the abstract class has overriden the show method of the abstract class.
## 36. using final to stop overriding
The final keyword before the variable makes the variable fial whicch is to make tha  unchangeable variable the same case happens here. If we declare a class that is said to be final then none other classes that extending the class containing the final method can be overriden. if we try to override the method of other classes it shows an error. for Example,

```java
class A{
  final void display(){
    System.out.println("The display method inside class A.");
  };
}

class B extends A{
  void display(){
    System.out.println("The display method inside class B.");
  }
} 
```
If we look at the above code here the method inside the class A called Display is defined as a final method, so the display method inside the class A cannot be overriden by the subclasses if class A.

>**Note :** note that the methods inside the abstract classes cannot be made as final. Because, the usage of the abstract class is to override the methods that has been defined inside the abstract class.so the final keyword cannot be used in the abstract classes or the methods that has be declared inside the abstract class.

## 37. Using final to prevent inheritance
Using final to stop inheritance is that if a class is made as final then the class cannot be inherited by anyother classes or in other words it cannot have any subclasses as like overriding and the alteration of variables is not possible when it is final. if we use the final keyword before the class then the class cannot be derived or it cannot have any subclasses. For example take the program given below.

```java   
final class A{
  void display(){
    System.out.println("The display method inside class A.");
  };
}

class B extends A{      //this inheritance is not possible because the class A is declared as a final class whichh means that we cannot inherit this class.
  void display(){
    System.out.println("The display method inside class B.");
  }
}
```
It would probably throws an error cause, we are trying to inherit a class that has been declared as final.
## 38. Object class
We have a class named object class in java. all the other classes are the subclasses of the object class. so we use the default methods like toString(), equal(), wait(), notifyAll(), notify(), getClass().

## 39. Packages
Packages are like containers that keep our class files namspaces seperated in order to protect from namespace conflicts. Pakages are nothing but maintaining classes in the folders. there can be more than one classes inside the package folder. It will be in a hierarchy manner with easy to use namespaces. For example, consider you are creating a class named Library if there is another classnamed Library which is created by another person there will be a name space conflict. in order to avoid that we can create out own packages.

### Advantages of Packages
- It removes naming collisions
- It provides some access levels for the classes.
- It is used to categorize the classes and Interfaces to maintain easy accessibilities.

So, Now how can we define package for our program its so much easy we must use the `package` keyword
if we need to define a package for this program Library.java we need to use the define keyword followed by the new package name we are going to use. So lets define a package for the above program.

```java
package MyPackage;

class Library{
  public static void main (String args[]){ 
    ..........
```
Now the above progrma is defined to the package named MyPackage. and we need to make sure that the program we define inside the package must be present in the folder with the same name of package. For example, the folder path for the above program will be like 

```bash   
c:\Users\JavaSamplePrograms\myPackage> 
```
So as like metioned above the package defined inside the program must be present in the directory which has the same name space

>**Note :** A special point to note is that the package namspace are mostly written in small letter in order to avoid name space conflict in case of having same name for package and class name.

So now we have defined package for our program. How will the Java Runtime knows the classfiles inside the package. It can be done in three ways
- The first way is that the classes are in subfolders inside the immidiate working directory. In other words the package folders are sub-directories of the working directory.

- The second way is by defining the CLASSPATH variable in the system varibale setting. 

- The third way is by defining the -classpath.

## 40. Access protection
Java class is a small piece of abstraction of code cause, If we declare private variables inside the class then it is not available outsde that class. We have seen the access protection given by the access modifiers in the preceding topics. here is the table of access protection.

Access levels | Private | Default | Protected | Public
---| ---| ---| ---| ---| 
**within class** | Yes |Yes | Yes |Yes
**within package** | No |Yes | Yes | Yes
**outside package but subclass** | No | No | Yes | Yes
**outside package** | No | No | No | Yes

here the access protection for the packages and the access outside the packages are also shown above.

## 41. Importing packages
In order to use tha packages that we have created we need to import them into our program. to import those packages we can use the `import `keyword.

consider a package called mypackage is there we have an Addition class which has the add method for adding two numbers then we need to import the package like 
```bash
import mypackage.Addition;
```
it imports the Addition class along with the methods inside it so we can use it like follow
```java
import mypackage.Addition;

class MainClass {
  public static void main (String args[]){
    int a = 9;
    int b = 6;
    int c = Addition.sum(a,b);

    System.out.println(c);
  }
}
```
inside the Addition class :
```java
Package mypackage;

public class Addition{
  public static int sum (int i, int j){
    return i+j;
  }
}
```
We have defined that the above class is a part of mypackage. The sum method inside the addition class returns the addition of the two arguments that has been passed.

In the main class we have imported the Addition class that contains the sum method by adding the import mypackage in main class.and after that in the value of c we have called the static method sum of that class to get a return value and the return value is assigned to the variable c.

## 42. Interfaces
Interfaces are considered as requirement specifications. for example lets take a scenario is a person is asking for features which he wants as mandatory. and the service provider who is going to complete the task must implement all the needs that have been asked for. so the interface contains all the methods that are needed as mandatory. but it will just declare the methods that are in need. the class that is going to implement this interface is going  to fill those methods or define those methods.  It is mandatory that all the classes that implements the interface must override the abstract methods that has been declared inside the interface. In case if a method inside an Interface is not overriden by the class that extends this interface. the Interface looks similar to the classes but it is defined  by the `interface` keyword. following is an example.

```java
interface Interface_name{

  access type method(); //just declaration  

}
```

## 43. Implementing interfaces
As like subclasses uses extend to  derive a super class here we use `implements` keyword to implement the interfaces. lets see how to implement interface.
```java 
interface Client {
  public void run();
  public void walk();
}

class ServiceProvider implements Client{
  public void run(){
    System.out.println("Client can run now.");
  }
  public void walk(){
    System.out.println("Client can walk now.");
  }
}

class InterfaceClass{
  public static void main (String args[]){

    ServiceProvide obj = new ServiceProvider();

    obj.run();
    obj.walk();
  }
}
```
so in the above example the client asked for two requirements which are mandatory so it is in interface the service provider who is going to take over the customers works must implement all the requirements that are described inside interface. That is the exact same thing happening here. When the ServiceProvider class implements the customer interface it must override all the abstract methods inside the interface. here the ServiceProvider class have overriden the methods and it is a clear implementation of interface.
## 44. Partial implementation
now we have seen the implementation of interfaces. when a class is implementing an interface then the class must give a full implementation of an interface. if the class is unable to fully implement an interface then it show error in order to avoid this we can make tha class as abstract which implements the interface. If we declare the class as `abstract` it is assumed as a incomplete class the class is not completed fully.but if any other class that extends the abstract class that implements an inteface which does not implement a interface completely then the subclass is responsible for the implemention if the subclass does not procide any implementation then it also shows error.
conside the below example. consider the below example program.

```java
interface Client{
    public void run();
    public void walk();
}

abstract class ServiceProvider implements Client{

    public void run() {
        System.out.println("Client can run now.");

    }
}

class SubServiceProvider extends ServiceProvider{

    public void walk() {
        System.out.println("Client can walk now.");

    }
}

public class InterfaceExample {

    public static void main (String args[]){
        ServiceProvider obj = new SubServiceProvider();

        obj.run();
        obj.walk();
    }

}

```

In the above program the class that implements the Client interface is not fully completed and so the class is made abstract.
## 45. Nested interfaces
Nestead interfaces are interface that are declared inside the classes or another interfaces. for example if there is an interface like application that interface will have the fetures of that application and within each feature there will be many methods to make the feature work. so the each seperate feature inside the interface can also be considered as interface of features. lets see an example how an nested interface looks and hwo they can be implemented
## 46. Applying interfaces 
Lets implement interface with an example.
```java
interface Watch {
    void showTime();
    void showDate();
    void ShowSeconds();
}

class DialWatch implements Watch{

    @Override
    public void showTime() {
        System.out.println("showing time...");
    }

    @Override
    public void showDate() {
        System.out.println("showing date...");
    }

    @Override
    public void ShowSeconds() {
        System.out.println("showing seconds...");
    }
}

public class ApplyInterface {
    public static void main (String args[]){
        DialWatch obj = new DialWatch();
        obj.showDate();
        obj.showTime();
        obj.ShowSeconds();
    }
}

```
### Output :

```bash
c:\Users\ExampleProgram> javac ApplyInterface.java
c:\Users\ExampleProgram> java ApplyInterface 

showing date...
showing time...
showing seconds...

Process finished with exit code 0
```
In the above program we have declared an interface which has been extended by the dialwatch class and all the abstract methods given inside the interface are overriden.hence the above program works perfectly.
## 47. interfaces can be extended
We can even extend interfaces as like classes extends another class. the reason for extended interface is, Lets consider an example we have an interface vehicle. Whatever the vehicle might be like car, bike,boat or anything. but the essetial need of vehicle is service so lets make the service method inside the vehicle interface and the second things lets consider fuel. each vehicle needs fuel. so lets declare the fuel method inside the vehicle interface. and now we are having two wheeler which has different features and four wheeler has different features 
so by extending two different interface we can seperate them and easy to maintain. we dont need to implement the two wheeler methods to the car methods thats the concept.
below is an example program for the extended interfaces

```java
interface vehicle {
    void serviceCondition();
    void fuelMethod();
}
interface TwoWheeler extends vehicle{
    void standCheck();
    void ridersCheck();
}
interface fourWheeler extends vehicle{

    void banetCheck();

    void seatBeltCheck();
}

class volkswagon implements fourWheeler{

    @Override
    public void serviceCondition() {
        System.out.println("two months once..");
    }

    @Override
    public void fuelMethod() {
        System.out.println("diesel type");
    }

    @Override
    public void banetCheck() {
        System.out.println("check the roof is good");
    }

    @Override
    public void seatBeltCheck() {
        System.out.println("Seatbelt is mandatory");
    }
}

class Tvs implements TwoWheeler{

    @Override
    public void serviceCondition() {
        System.out.println("four month once ");
    }

    @Override
    public void fuelMethod() {
        System.out.println("fuel method is petrol.");
    }

    @Override
    public void standCheck() {
        System.out.println("check whether the stand is pulled in before ride.");
    }

    @Override
    public void ridersCheck() {
        System.out.println("only two persons are allowed to ride usign two wheeler.");
    }
}

public class ExtendedInterface {

    public static void main(String[] args) {
        Tvs bike = new Tvs();
        bike.fuelMethod();
        bike.ridersCheck();
        bike.ridersCheck();
        bike.fuelMethod();

        System.out.println();

        volkswagon car = new volkswagon();
        car.banetCheck();
        car.fuelMethod();
        car.seatBeltCheck();
        car.serviceCondition();
    }

}

```
### Output :

```bash
c:\Users\ExampleProgram> javac ExtendedInterface.java
c:\Users\ExampleProgram> java ExtendedInterface 

fuel method is petrol.
only two persons are allowed to ride usign two wheeler.
only two persons are allowed to ride usign two wheeler.
fuel method is petrol.

check the roof is goof
diesel type
Seatbelt is mandatory
two months once..

Process finished with exit code 0
```
> **UPDATING...**


 
  